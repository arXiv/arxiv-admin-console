# coding: utf-8

"""
    FastAPI

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from arxiv_admin_api.apis.modapi.modapi_client.models.admin_submission_flags import AdminSubmissionFlags
from arxiv_admin_api.apis.modapi.modapi_client.models.categories import Categories
from arxiv_admin_api.apis.modapi.modapi_client.models.hold_reason import HoldReason
from arxiv_admin_api.apis.modapi.modapi_client.models.hold_type import HoldType
from arxiv_admin_api.apis.modapi.modapi_client.models.source_format import SourceFormat
from arxiv_admin_api.apis.modapi.modapi_client.models.submission_urls import SubmissionUrls
from arxiv_admin_api.apis.modapi.modapi_client.models.submitter import Submitter
from typing import Optional, Set
from typing_extensions import Self

class AdminSubmission(BaseModel):
    """
    Mixin to extend the `modapi.rest.schema.Submission` with additional properties needed by the admins
    """ # noqa: E501
    submission_id: StrictInt
    doc_paper_id: Optional[StrictStr] = None
    created: Optional[datetime] = None
    updated: Optional[datetime] = None
    submit_time: Optional[datetime] = None
    release_time: Optional[datetime] = None
    status: StrictStr
    status_name: Optional[StrictStr] = None
    version: Optional[StrictInt] = None
    type: Optional[StrictStr] = None
    title: Optional[StrictStr] = None
    authors: Optional[StrictStr] = None
    abstract: Optional[StrictStr] = None
    comments: Optional[StrictStr] = None
    is_author: Optional[StrictInt] = None
    sword_id: Optional[StrictInt] = None
    proxy: Optional[StrictStr] = None
    contact_name: Optional[StrictStr]
    contact_email: Optional[StrictStr]
    report_num: Optional[StrictStr] = None
    msc_class: Optional[StrictStr] = None
    acm_class: Optional[StrictStr] = None
    journal_ref: Optional[StrictStr] = None
    doi: Optional[StrictStr] = None
    is_ok: Optional[StrictBool] = None
    admin_ok: Optional[StrictBool] = None
    auto_hold: Optional[StrictBool] = None
    is_locked: Optional[StrictBool] = None
    categories: Categories
    submitter: Submitter
    comment_count: Optional[StrictInt] = None
    matched: StrictStr
    hold_type: Optional[HoldType] = None
    hold_reason: Optional[HoldReason] = None
    urls: Optional[SubmissionUrls] = None
    license: Optional[StrictStr] = None
    source_format: Optional[SourceFormat] = None
    allow_tex_produced: Optional[StrictBool] = None
    submission_flags: Optional[AdminSubmissionFlags] = None
    edit_token: StrictStr
    source_size: Optional[StrictInt] = None
    preflight: Optional[StrictBool] = None
    __properties: ClassVar[List[str]] = ["submission_id", "doc_paper_id", "created", "updated", "submit_time", "release_time", "status", "status_name", "version", "type", "title", "authors", "abstract", "comments", "is_author", "sword_id", "proxy", "contact_name", "contact_email", "report_num", "msc_class", "acm_class", "journal_ref", "doi", "is_ok", "admin_ok", "auto_hold", "is_locked", "categories", "submitter", "comment_count", "matched", "hold_type", "hold_reason", "urls", "license", "source_format", "allow_tex_produced", "submission_flags", "edit_token", "source_size", "preflight"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AdminSubmission from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of categories
        if self.categories:
            _dict['categories'] = self.categories.to_dict()
        # override the default output from pydantic by calling `to_dict()` of submitter
        if self.submitter:
            _dict['submitter'] = self.submitter.to_dict()
        # override the default output from pydantic by calling `to_dict()` of hold_reason
        if self.hold_reason:
            _dict['hold_reason'] = self.hold_reason.to_dict()
        # override the default output from pydantic by calling `to_dict()` of urls
        if self.urls:
            _dict['urls'] = self.urls.to_dict()
        # override the default output from pydantic by calling `to_dict()` of submission_flags
        if self.submission_flags:
            _dict['submission_flags'] = self.submission_flags.to_dict()
        # set to None if doc_paper_id (nullable) is None
        # and model_fields_set contains the field
        if self.doc_paper_id is None and "doc_paper_id" in self.model_fields_set:
            _dict['doc_paper_id'] = None

        # set to None if created (nullable) is None
        # and model_fields_set contains the field
        if self.created is None and "created" in self.model_fields_set:
            _dict['created'] = None

        # set to None if updated (nullable) is None
        # and model_fields_set contains the field
        if self.updated is None and "updated" in self.model_fields_set:
            _dict['updated'] = None

        # set to None if submit_time (nullable) is None
        # and model_fields_set contains the field
        if self.submit_time is None and "submit_time" in self.model_fields_set:
            _dict['submit_time'] = None

        # set to None if release_time (nullable) is None
        # and model_fields_set contains the field
        if self.release_time is None and "release_time" in self.model_fields_set:
            _dict['release_time'] = None

        # set to None if status_name (nullable) is None
        # and model_fields_set contains the field
        if self.status_name is None and "status_name" in self.model_fields_set:
            _dict['status_name'] = None

        # set to None if version (nullable) is None
        # and model_fields_set contains the field
        if self.version is None and "version" in self.model_fields_set:
            _dict['version'] = None

        # set to None if type (nullable) is None
        # and model_fields_set contains the field
        if self.type is None and "type" in self.model_fields_set:
            _dict['type'] = None

        # set to None if title (nullable) is None
        # and model_fields_set contains the field
        if self.title is None and "title" in self.model_fields_set:
            _dict['title'] = None

        # set to None if authors (nullable) is None
        # and model_fields_set contains the field
        if self.authors is None and "authors" in self.model_fields_set:
            _dict['authors'] = None

        # set to None if abstract (nullable) is None
        # and model_fields_set contains the field
        if self.abstract is None and "abstract" in self.model_fields_set:
            _dict['abstract'] = None

        # set to None if comments (nullable) is None
        # and model_fields_set contains the field
        if self.comments is None and "comments" in self.model_fields_set:
            _dict['comments'] = None

        # set to None if is_author (nullable) is None
        # and model_fields_set contains the field
        if self.is_author is None and "is_author" in self.model_fields_set:
            _dict['is_author'] = None

        # set to None if sword_id (nullable) is None
        # and model_fields_set contains the field
        if self.sword_id is None and "sword_id" in self.model_fields_set:
            _dict['sword_id'] = None

        # set to None if proxy (nullable) is None
        # and model_fields_set contains the field
        if self.proxy is None and "proxy" in self.model_fields_set:
            _dict['proxy'] = None

        # set to None if contact_name (nullable) is None
        # and model_fields_set contains the field
        if self.contact_name is None and "contact_name" in self.model_fields_set:
            _dict['contact_name'] = None

        # set to None if contact_email (nullable) is None
        # and model_fields_set contains the field
        if self.contact_email is None and "contact_email" in self.model_fields_set:
            _dict['contact_email'] = None

        # set to None if report_num (nullable) is None
        # and model_fields_set contains the field
        if self.report_num is None and "report_num" in self.model_fields_set:
            _dict['report_num'] = None

        # set to None if msc_class (nullable) is None
        # and model_fields_set contains the field
        if self.msc_class is None and "msc_class" in self.model_fields_set:
            _dict['msc_class'] = None

        # set to None if acm_class (nullable) is None
        # and model_fields_set contains the field
        if self.acm_class is None and "acm_class" in self.model_fields_set:
            _dict['acm_class'] = None

        # set to None if journal_ref (nullable) is None
        # and model_fields_set contains the field
        if self.journal_ref is None and "journal_ref" in self.model_fields_set:
            _dict['journal_ref'] = None

        # set to None if doi (nullable) is None
        # and model_fields_set contains the field
        if self.doi is None and "doi" in self.model_fields_set:
            _dict['doi'] = None

        # set to None if is_ok (nullable) is None
        # and model_fields_set contains the field
        if self.is_ok is None and "is_ok" in self.model_fields_set:
            _dict['is_ok'] = None

        # set to None if admin_ok (nullable) is None
        # and model_fields_set contains the field
        if self.admin_ok is None and "admin_ok" in self.model_fields_set:
            _dict['admin_ok'] = None

        # set to None if auto_hold (nullable) is None
        # and model_fields_set contains the field
        if self.auto_hold is None and "auto_hold" in self.model_fields_set:
            _dict['auto_hold'] = None

        # set to None if is_locked (nullable) is None
        # and model_fields_set contains the field
        if self.is_locked is None and "is_locked" in self.model_fields_set:
            _dict['is_locked'] = None

        # set to None if comment_count (nullable) is None
        # and model_fields_set contains the field
        if self.comment_count is None and "comment_count" in self.model_fields_set:
            _dict['comment_count'] = None

        # set to None if hold_type (nullable) is None
        # and model_fields_set contains the field
        if self.hold_type is None and "hold_type" in self.model_fields_set:
            _dict['hold_type'] = None

        # set to None if hold_reason (nullable) is None
        # and model_fields_set contains the field
        if self.hold_reason is None and "hold_reason" in self.model_fields_set:
            _dict['hold_reason'] = None

        # set to None if urls (nullable) is None
        # and model_fields_set contains the field
        if self.urls is None and "urls" in self.model_fields_set:
            _dict['urls'] = None

        # set to None if license (nullable) is None
        # and model_fields_set contains the field
        if self.license is None and "license" in self.model_fields_set:
            _dict['license'] = None

        # set to None if source_format (nullable) is None
        # and model_fields_set contains the field
        if self.source_format is None and "source_format" in self.model_fields_set:
            _dict['source_format'] = None

        # set to None if allow_tex_produced (nullable) is None
        # and model_fields_set contains the field
        if self.allow_tex_produced is None and "allow_tex_produced" in self.model_fields_set:
            _dict['allow_tex_produced'] = None

        # set to None if submission_flags (nullable) is None
        # and model_fields_set contains the field
        if self.submission_flags is None and "submission_flags" in self.model_fields_set:
            _dict['submission_flags'] = None

        # set to None if source_size (nullable) is None
        # and model_fields_set contains the field
        if self.source_size is None and "source_size" in self.model_fields_set:
            _dict['source_size'] = None

        # set to None if preflight (nullable) is None
        # and model_fields_set contains the field
        if self.preflight is None and "preflight" in self.model_fields_set:
            _dict['preflight'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AdminSubmission from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "submission_id": obj.get("submission_id"),
            "doc_paper_id": obj.get("doc_paper_id"),
            "created": obj.get("created"),
            "updated": obj.get("updated"),
            "submit_time": obj.get("submit_time"),
            "release_time": obj.get("release_time"),
            "status": obj.get("status"),
            "status_name": obj.get("status_name"),
            "version": obj.get("version"),
            "type": obj.get("type"),
            "title": obj.get("title"),
            "authors": obj.get("authors"),
            "abstract": obj.get("abstract"),
            "comments": obj.get("comments"),
            "is_author": obj.get("is_author"),
            "sword_id": obj.get("sword_id"),
            "proxy": obj.get("proxy"),
            "contact_name": obj.get("contact_name"),
            "contact_email": obj.get("contact_email"),
            "report_num": obj.get("report_num"),
            "msc_class": obj.get("msc_class"),
            "acm_class": obj.get("acm_class"),
            "journal_ref": obj.get("journal_ref"),
            "doi": obj.get("doi"),
            "is_ok": obj.get("is_ok"),
            "admin_ok": obj.get("admin_ok"),
            "auto_hold": obj.get("auto_hold"),
            "is_locked": obj.get("is_locked"),
            "categories": Categories.from_dict(obj["categories"]) if obj.get("categories") is not None else None,
            "submitter": Submitter.from_dict(obj["submitter"]) if obj.get("submitter") is not None else None,
            "comment_count": obj.get("comment_count"),
            "matched": obj.get("matched"),
            "hold_type": obj.get("hold_type"),
            "hold_reason": HoldReason.from_dict(obj["hold_reason"]) if obj.get("hold_reason") is not None else None,
            "urls": SubmissionUrls.from_dict(obj["urls"]) if obj.get("urls") is not None else None,
            "license": obj.get("license"),
            "source_format": obj.get("source_format"),
            "allow_tex_produced": obj.get("allow_tex_produced"),
            "submission_flags": AdminSubmissionFlags.from_dict(obj["submission_flags"]) if obj.get("submission_flags") is not None else None,
            "edit_token": obj.get("edit_token"),
            "source_size": obj.get("source_size"),
            "preflight": obj.get("preflight")
        })
        return _obj


